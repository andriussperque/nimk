/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
const vscode_debugadapter_1 = require('vscode-debugadapter');
const chromeConnection_1 = require('./chromeConnection');
const ChromeUtils = require('./chromeUtils');
const variables_1 = require('./variables');
const consoleHelper_1 = require('./consoleHelper');
const errors = require('../errors');
const utils = require('../utils');
const logger = require('../logger');
const lineNumberTransformer_1 = require('../transformers/lineNumberTransformer');
const remotePathTransformer_1 = require('../transformers/remotePathTransformer');
const eagerSourceMapTransformer_1 = require('../transformers/eagerSourceMapTransformer');
const path = require('path');
class ChromeDebugAdapter {
    constructor({ chromeConnection, lineColTransformer, sourceMapTransformer, pathTransformer }, session) {
        this._currentStep = Promise.resolve();
        this._nextUnboundBreakpointId = 0;
        this._session = session;
        this._chromeConnection = new (chromeConnection || chromeConnection_1.ChromeConnection)();
        this._variableHandles = new vscode_debugadapter_1.Handles();
        this._breakpointIdHandles = new utils.ReverseHandles();
        this._sourceHandles = new vscode_debugadapter_1.Handles();
        this._pendingBreakpointsByUrl = new Map();
        this._overlayHelper = new utils.DebounceHelper(/*timeoutMs=*/ 200);
        this._lineColTransformer = new (lineColTransformer || lineNumberTransformer_1.LineColTransformer)(this._session);
        this._sourceMapTransformer = new (sourceMapTransformer || eagerSourceMapTransformer_1.EagerSourceMapTransformer)(this._sourceHandles);
        this._pathTransformer = new (pathTransformer || remotePathTransformer_1.RemotePathTransformer)();
        this.clearTargetContext();
    }
    get paused() {
        return !!this._currentStack;
    }
    /**
     * Called on 'clearEverything' or on a navigation/refresh
     */
    clearTargetContext() {
        this._sourceMapTransformer.clearTargetContext();
        this._scriptsById = new Map();
        this._scriptsByUrl = new Map();
        this._committedBreakpointsByUrl = new Map();
        this._setBreakpointsRequestQ = Promise.resolve();
        this._pathTransformer.clearTargetContext();
    }
    initialize(args) {
        if (args.pathFormat !== 'path') {
            return Promise.reject(errors.pathFormat());
        }
        // because session bypasses dispatchRequest
        if (typeof args.linesStartAt1 === 'boolean') {
            this._clientLinesStartAt1 = args.linesStartAt1;
        }
        if (typeof args.columnsStartAt1 === 'boolean') {
            this._clientColumnsStartAt1 = args.columnsStartAt1;
        }
        // This debug adapter supports two exception breakpoint filters
        return {
            exceptionBreakpointFilters: [
                {
                    label: 'All Exceptions',
                    filter: 'all',
                    default: false
                },
                {
                    label: 'Uncaught Exceptions',
                    filter: 'uncaught',
                    default: true
                }
            ],
            supportsConfigurationDoneRequest: true,
            supportsSetVariable: true,
            supportsConditionalBreakpoints: true
        };
    }
    configurationDone() {
        return Promise.resolve();
    }
    launch(args) {
        this._sourceMapTransformer.launch(args);
        this._pathTransformer.launch(args);
        this.setupLogging(args);
        return Promise.resolve();
    }
    attach(args) {
        this._attachMode = true;
        this._sourceMapTransformer.attach(args);
        this._pathTransformer.attach(args);
        if (args.port == null) {
            return utils.errP('The "port" field is required in the attach config.');
        }
        this.setupLogging(args);
        return this.doAttach(args.port, args.url, args.address);
    }
    setupLogging(args) {
        const minLogLevel = args.verboseDiagnosticLogging ?
            logger.LogLevel.Verbose :
            args.diagnosticLogging ?
                logger.LogLevel.Log :
                logger.LogLevel.Error;
        logger.setMinLogLevel(minLogLevel);
    }
    /**
     * From DebugSession
     */
    shutdown() {
        this._inShutdown = true;
    }
    /**
     * Chrome is closing, or error'd somehow, stop the debug session
     */
    terminateSession(reason, restart) {
        logger.log('Terminated: ' + reason);
        if (!this._hasTerminated) {
            this._hasTerminated = true;
            if (this._clientAttached) {
                this._session.sendEvent(new vscode_debugadapter_1.TerminatedEvent(restart));
            }
            if (this._chromeConnection.isAttached) {
                this._chromeConnection.close();
            }
        }
    }
    doAttach(port, targetUrl, address, timeout) {
        // Client is attaching - if not attached to the chrome target, create a connection and attach
        this._clientAttached = true;
        if (!this._chromeConnection.isAttached) {
            this._chromeConnection.on('Debugger.paused', params => this.onDebuggerPaused(params));
            this._chromeConnection.on('Debugger.resumed', () => this.onDebuggerResumed());
            this._chromeConnection.on('Debugger.scriptParsed', params => this.onScriptParsed(params));
            this._chromeConnection.on('Debugger.globalObjectCleared', () => this.onGlobalObjectCleared());
            this._chromeConnection.on('Debugger.breakpointResolved', params => this.onBreakpointResolved(params));
            this._chromeConnection.on('Console.messageAdded', params => this.onConsoleMessage(params));
            this._chromeConnection.on('Inspector.detached', () => this.terminateSession('Debug connection detached'));
            this._chromeConnection.on('close', () => this.terminateSession('Debug connection closed'));
            this._chromeConnection.on('error', e => this.terminateSession('Debug connection error: ' + e));
            return this._chromeConnection.attach(address, port, targetUrl)
                .then(() => this.sendInitializedEvent());
        }
        else {
            return Promise.resolve();
        }
    }
    /**
     * This event tells the client to begin sending setBP requests, etc. Some consumers need to override this
     * to send it at a later time of their choosing.
     */
    sendInitializedEvent() {
        this._session.sendEvent(new vscode_debugadapter_1.InitializedEvent());
    }
    /**
     * e.g. the target navigated
     */
    onGlobalObjectCleared() {
        this.clearTargetContext();
    }
    onDebuggerPaused(notification) {
        this._exception = undefined;
        this._overlayHelper.doAndCancel(() => this._chromeConnection.page_configureOverlay(ChromeDebugAdapter.PAGE_PAUSE_MESSAGE));
        this._currentStack = notification.callFrames;
        // We can tell when we've broken on an exception. Otherwise if hitBreakpoints is set, assume we hit a
        // breakpoint. If not set, assume it was a step. We can't tell the difference between step and 'break on anything'.
        let reason;
        let exceptionText;
        if (notification.reason === 'exception') {
            reason = 'exception';
            this._exception = notification.data;
        }
        else if (notification.hitBreakpoints && notification.hitBreakpoints.length) {
            reason = 'breakpoint';
        }
        else {
            reason = this._expectingStopReason || 'debugger';
        }
        this._expectingStopReason = undefined;
        // Enforce that the stopped event is not fired until we've send the response to the step that induced it.
        // Also with a timeout just to ensure things keep moving
        const sendStoppedEvent = () => this._session.sendEvent(new vscode_debugadapter_1.StoppedEvent(this.stopReasonText(reason), /*threadId=*/ ChromeDebugAdapter.THREAD_ID, exceptionText));
        utils.promiseTimeout(this._currentStep, /*timeoutMs=*/ 300)
            .then(sendStoppedEvent, sendStoppedEvent);
    }
    stopReasonText(reason) {
        const comment = ['https://github.com/Microsoft/vscode/issues/4568'];
        switch (reason) {
            case 'entry':
                return utils.localize({ key: 'reason.entry', comment }, "entry");
            case 'exception':
                return utils.localize({ key: 'reason.exception', comment }, "exception");
            case 'breakpoint':
                return utils.localize({ key: 'reason.breakpoint', comment }, "breakpoint");
            case 'debugger':
                return utils.localize({ key: 'reason.debugger_statement', comment }, "debugger statement");
            case 'frame_entry':
                return utils.localize({ key: 'reason.restart', comment }, "frame entry");
            case 'step':
                return utils.localize({ key: 'reason.step', comment }, "step");
            case 'user_request':
                return utils.localize({ key: 'reason.user_request', comment }, "user request");
            default:
                return reason;
        }
    }
    onDebuggerResumed() {
        this._overlayHelper.wait(() => this._chromeConnection.page_configureOverlay(undefined));
        this._currentStack = null;
        if (!this._expectingResumedEvent) {
            let resumedEvent = new vscode_debugadapter_1.ContinuedEvent(ChromeDebugAdapter.THREAD_ID);
            this._session.sendEvent(resumedEvent);
        }
        else {
            this._expectingResumedEvent = false;
        }
    }
    onScriptParsed(script) {
        // Totally ignore extension scripts, internal Chrome scripts, and so on
        if (this.shouldIgnoreScript(script)) {
            return;
        }
        if (!script.url) {
            script.url = ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL + script.scriptId;
        }
        this._scriptsById.set(script.scriptId, script);
        this._scriptsByUrl.set(script.url, script);
        const mappedUrl = this._pathTransformer.scriptParsed(script.url);
        this._sourceMapTransformer.scriptParsed(mappedUrl, script.sourceMapURL).then(sources => {
            if (sources) {
                sources.forEach(source => {
                    if (this._pendingBreakpointsByUrl.has(source)) {
                        this.resolvePendingBreakpoints(this._pendingBreakpointsByUrl.get(source));
                    }
                });
            }
        });
    }
    resolvePendingBreakpoints(pendingBP) {
        this.setBreakpoints(pendingBP.args, 0).then(response => {
            response.breakpoints.forEach((bp, i) => {
                bp.id = pendingBP.ids[i];
                this._session.sendEvent(new vscode_debugadapter_1.BreakpointEvent('new', bp));
            });
        });
    }
    onBreakpointResolved(params) {
        const script = this._scriptsById.get(params.location.scriptId);
        if (!script) {
            // Breakpoint resolved for a script we don't know about
            return;
        }
        const committedBps = this._committedBreakpointsByUrl.get(script.url) || [];
        committedBps.push(params.breakpointId);
        this._committedBreakpointsByUrl.set(script.url, committedBps);
        const bp = {
            id: this._breakpointIdHandles.lookup(params.breakpointId),
            verified: true,
            line: params.location.lineNumber,
            column: params.location.columnNumber
        };
        const scriptPath = this._pathTransformer.breakpointResolved(bp, script.url);
        this._sourceMapTransformer.breakpointResolved(bp, scriptPath);
        this._lineColTransformer.breakpointResolved(bp);
        this._session.sendEvent(new vscode_debugadapter_1.BreakpointEvent('new', bp));
    }
    onConsoleMessage(params) {
        const formattedMessage = consoleHelper_1.formatConsoleMessage(params.message);
        if (formattedMessage) {
            this._session.sendEvent(new vscode_debugadapter_1.OutputEvent(formattedMessage.text + '\n', formattedMessage.isError ? 'stderr' : 'stdout'));
        }
    }
    disconnect() {
        return this.terminateSession('Got disconnect request');
    }
    setBreakpoints(args, requestSeq) {
        return this.validateBreakpointsPath(args)
            .then(() => {
            this._lineColTransformer.setBreakpoints(args);
            this._sourceMapTransformer.setBreakpoints(args, requestSeq);
            this._pathTransformer.setBreakpoints(args);
            let targetScriptUrl;
            if (args.source.path) {
                targetScriptUrl = args.source.path;
            }
            else if (args.source.sourceReference) {
                const handle = this._sourceHandles.get(args.source.sourceReference);
                const targetScript = this._scriptsById.get(handle.scriptId);
                if (targetScript) {
                    targetScriptUrl = targetScript.url;
                }
            }
            if (targetScriptUrl) {
                // DebugProtocol sends all current breakpoints for the script. Clear all scripts for the breakpoint then add all of them
                const setBreakpointsPFailOnError = this._setBreakpointsRequestQ
                    .then(() => this.clearAllBreakpoints(targetScriptUrl))
                    .then(() => this.addBreakpoints(targetScriptUrl, args.breakpoints))
                    .then(responses => ({ breakpoints: this.chromeBreakpointResponsesToODPBreakpoints(targetScriptUrl, responses, args.breakpoints) }));
                const setBreakpointsPTimeout = utils.promiseTimeout(setBreakpointsPFailOnError, ChromeDebugAdapter.SET_BREAKPOINTS_TIMEOUT, 'Set breakpoints request timed out');
                // Do just one setBreakpointsRequest at a time to avoid interleaving breakpoint removed/breakpoint added requests to Chrome.
                // Swallow errors in the promise queue chain so it doesn't get blocked, but return the failing promise for error handling.
                this._setBreakpointsRequestQ = setBreakpointsPTimeout.catch(() => undefined);
                return setBreakpointsPTimeout.then(body => {
                    this._sourceMapTransformer.setBreakpointsResponse(body, requestSeq);
                    this._lineColTransformer.setBreakpointsResponse(body);
                    return body;
                });
            }
            else {
                return Promise.resolve(this.unverifiedBpResponse(args, utils.localize('bp.fail.noscript', `Can't find script for breakpoint request`)));
            }
        }, e => this.unverifiedBpResponse(args, e.message));
    }
    validateBreakpointsPath(args) {
        if (!args.source.path)
            return Promise.resolve();
        return this._sourceMapTransformer.getGeneratedPathFromAuthoredPath(args.source.path).then(mappedPath => {
            if (!mappedPath) {
                return utils.errP(utils.localize('sourcemapping.fail.message', "Breakpoint ignored because generated code not found (source map problem?)."));
            }
            const targetPath = this._pathTransformer.getTargetPathFromClientPath(mappedPath);
            if (!targetPath) {
                return utils.errP('Breakpoint ignored because target path not found');
            }
            return undefined;
        });
    }
    unverifiedBpResponse(args, message) {
        const breakpoints = args.breakpoints.map(bp => {
            return {
                verified: false,
                line: bp.line,
                column: bp.column,
                message,
                id: this._breakpointIdHandles.create(this._nextUnboundBreakpointId++ + '')
            };
        });
        if (args.source.path) {
            const ids = breakpoints.map(bp => bp.id);
            this._pendingBreakpointsByUrl.set(args.source.path, { args, ids });
        }
        return { breakpoints };
    }
    clearAllBreakpoints(url) {
        if (!this._committedBreakpointsByUrl.has(url)) {
            return Promise.resolve();
        }
        // Remove breakpoints one at a time. Seems like it would be ok to send the removes all at once,
        // but there is a chrome bug where when removing 5+ or so breakpoints at once, it gets into a weird
        // state where later adds on the same line will fail with 'breakpoint already exists' even though it
        // does not break there.
        return this._committedBreakpointsByUrl.get(url).reduce((p, bpId) => {
            return p.then(() => this._chromeConnection.debugger_removeBreakpoint(bpId)).then(() => { });
        }, Promise.resolve()).then(() => {
            this._committedBreakpointsByUrl.set(url, null);
        });
    }
    /**
     * Makes the actual call to either Debugger.setBreakpoint or Debugger.setBreakpointByUrl, and returns the response.
     * Responses from setBreakpointByUrl are transformed to look like the response from setBreakpoint, so they can be
     * handled the same.
     */
    addBreakpoints(url, breakpoints) {
        let responsePs;
        if (url.startsWith(ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL)) {
            // eval script with no real url - use debugger_setBreakpoint
            const scriptId = utils.lstrip(url, ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL);
            responsePs = breakpoints.map(({ line, column = 0, condition }, i) => this._chromeConnection.debugger_setBreakpoint({ scriptId, lineNumber: line, columnNumber: column }, condition));
        }
        else {
            // script that has a url - use debugger_setBreakpointByUrl so that Chrome will rebind the breakpoint immediately
            // after refreshing the page. This is the only way to allow hitting breakpoints in code that runs immediately when
            // the page loads.
            const script = this._scriptsByUrl.get(url);
            const urlRegex = utils.pathToRegex(url);
            responsePs = breakpoints.map(({ line, column = 0, condition }, i) => {
                return this._chromeConnection.debugger_setBreakpointByUrlRegex(urlRegex, line, column, condition).then(response => {
                    // Now convert the response to a SetBreakpointResponse so both response types can be handled the same
                    const locations = response.result.locations;
                    return {
                        id: response.id,
                        error: response.error,
                        result: {
                            breakpointId: response.result.breakpointId,
                            actualLocation: locations[0] && {
                                lineNumber: locations[0].lineNumber,
                                columnNumber: locations[0].columnNumber,
                                scriptId: script.scriptId
                            }
                        }
                    };
                });
            });
        }
        // Join all setBreakpoint requests to a single promise
        return Promise.all(responsePs);
    }
    chromeBreakpointResponsesToODPBreakpoints(url, responses, requestBps) {
        // Don't cache errored responses
        const committedBpIds = responses
            .filter(response => !response.error)
            .map(response => response.result.breakpointId);
        // Cache successfully set breakpoint ids from chrome in committedBreakpoints set
        this._committedBreakpointsByUrl.set(url, committedBpIds);
        // Map committed breakpoints to DebugProtocol response breakpoints
        return responses
            .map((response, i) => {
            const id = response.result ? this._breakpointIdHandles.create(response.result.breakpointId) : undefined;
            // The output list needs to be the same length as the input list, so map errors to
            // unverified breakpoints.
            if (response.error || !response.result.actualLocation) {
                return {
                    id,
                    verified: false,
                    line: requestBps[i].line,
                    column: requestBps[i].column || 0,
                };
            }
            return {
                id,
                verified: true,
                line: response.result.actualLocation.lineNumber,
                column: response.result.actualLocation.columnNumber
            };
        });
    }
    setExceptionBreakpoints(args) {
        let state;
        if (args.filters.indexOf('all') >= 0) {
            state = 'all';
        }
        else if (args.filters.indexOf('uncaught') >= 0) {
            state = 'uncaught';
        }
        else {
            state = 'none';
        }
        return this._chromeConnection.debugger_setPauseOnExceptions(state)
            .then(() => { });
    }
    continue() {
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_resume()
            .then(() => { });
    }
    next() {
        this._expectingStopReason = 'step';
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_stepOver()
            .then(() => { });
    }
    stepIn() {
        this._expectingStopReason = 'step';
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_stepIn()
            .then(() => { });
    }
    stepOut() {
        this._expectingStopReason = 'step';
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_stepOut()
            .then(() => { });
    }
    pause() {
        this._expectingStopReason = 'user_request';
        return this._currentStep = this._chromeConnection.debugger_pause()
            .then(() => { });
    }
    stackTrace(args) {
        // Only process at the requested number of frames, if 'levels' is specified
        let stack = this._currentStack;
        if (args.levels) {
            stack = this._currentStack.filter((_, i) => i < args.levels);
        }
        const stackFrames = stack
            .map(({ location, functionName }, i) => {
            const line = location.lineNumber;
            const column = location.columnNumber;
            const script = this._scriptsById.get(location.scriptId);
            try {
                // When the script has a url and isn't one we're ignoring, send the name and path fields. PathTransformer will
                // attempt to resolve it to a script in the workspace. Otherwise, send the name and sourceReference fields.
                const source = script && !this.shouldIgnoreScript(script) ?
                    {
                        name: path.basename(script.url),
                        path: script.url,
                        sourceReference: this._sourceHandles.create({ scriptId: script.scriptId })
                    } :
                    {
                        name: script && path.basename(script.url),
                        path: ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL + location.scriptId,
                        sourceReference: this._sourceHandles.create({ scriptId: location.scriptId })
                    };
                // If the frame doesn't have a function name, it's either an anonymous function
                // or eval script. If its source has a name, it's probably an anonymous function.
                const frameName = functionName || (script.url ? '(anonymous function)' : '(eval code)');
                return {
                    id: i,
                    name: frameName,
                    source,
                    line: line,
                    column
                };
            }
            catch (e) {
                // Some targets such as the iOS simulator behave badly and return nonsense callFrames.
                // In these cases, return a dummy stack frame
                return {
                    id: i,
                    name: 'Unknown',
                    source: { name: 'eval:Unknown', path: ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL + 'Unknown' },
                    line,
                    column
                };
            }
        });
        const stackTraceResponse = { stackFrames };
        this._pathTransformer.stackTraceResponse(stackTraceResponse);
        this._sourceMapTransformer.stackTraceResponse(stackTraceResponse);
        this._lineColTransformer.stackTraceResponse(stackTraceResponse);
        return stackTraceResponse;
    }
    scopes(args) {
        const currentFrame = this._currentStack[args.frameId];
        const scopes = currentFrame.scopeChain.map((scope, i) => {
            // The first scope should include 'this'. Keep the RemoteObject reference for use by the variables request
            const thisObj = i === 0 && currentFrame.this;
            const returnValue = i === 0 && currentFrame.returnValue;
            const variablesReference = this._variableHandles.create(new variables_1.ScopeContainer(currentFrame.callFrameId, i, scope.object.objectId, thisObj, returnValue));
            return {
                name: scope.type.substr(0, 1).toUpperCase() + scope.type.substr(1),
                variablesReference,
                expensive: scope.type === 'global'
            };
        });
        if (this._exception) {
            scopes.unshift({
                name: utils.localize('scope.exception', "Exception"),
                variablesReference: this._variableHandles.create(variables_1.ExceptionContainer.create(this._exception))
            });
        }
        return { scopes };
    }
    variables(args) {
        const handle = this._variableHandles.get(args.variablesReference);
        if (!handle) {
            return Promise.resolve(undefined);
        }
        return handle.expand(this, args.filter, args.start, args.count).then(variables => {
            return { variables };
        });
    }
    propertyDescriptorToVariable(propDesc, owningObjectId) {
        if (propDesc.get) {
            // Getter
            const grabGetterValue = 'function remoteFunction(propName) { return this[propName]; }';
            return this._chromeConnection.runtime_callFunctionOn(owningObjectId, grabGetterValue, [{ value: propDesc.name }]).then(response => {
                if (response.error) {
                    logger.error('Error evaluating getter - ' + response.error.toString());
                    return { name: propDesc.name, value: response.error.toString(), variablesReference: 0 };
                }
                else if (response.result.exceptionDetails) {
                    // Not an error, getter could be `get foo() { throw new Error('bar'); }`
                    const exceptionDetails = response.result.exceptionDetails;
                    logger.log('Exception thrown evaluating getter - ' + JSON.stringify(exceptionDetails.exception));
                    return { name: propDesc.name, value: response.result.exceptionDetails.exception.description, variablesReference: 0 };
                }
                else {
                    return this.remoteObjectToVariable(propDesc.name, response.result.result);
                }
            });
        }
        else if (propDesc.set) {
            // setter without a getter, unlikely
            return Promise.resolve({ name: propDesc.name, value: 'setter', variablesReference: 0 });
        }
        else {
            // Non getter/setter
            return this.internalPropertyDescriptorToVariable(propDesc);
        }
    }
    getVariablesForObjectId(objectId, filter, start, count) {
        if (typeof start === 'number' && typeof count === 'number') {
            return this.getFilteredVariablesForObject(objectId, filter, start, count);
        }
        return Promise.all([
            // Need to make two requests to get all properties
            this._chromeConnection.runtime_getProperties(objectId, /*ownProperties=*/ false, /*accessorPropertiesOnly=*/ true, /*generatePreview=*/ true),
            this._chromeConnection.runtime_getProperties(objectId, /*ownProperties=*/ true, /*accessorPropertiesOnly=*/ false, /*generatePreview=*/ true)
        ]).then(getPropsResponses => {
            // Sometimes duplicates will be returned - merge all descriptors by name
            const propsByName = new Map();
            const internalPropsByName = new Map();
            getPropsResponses.forEach(response => {
                if (!response.error) {
                    response.result.result.forEach(propDesc => propsByName.set(propDesc.name, propDesc));
                    if (response.result.internalProperties) {
                        response.result.internalProperties.forEach(internalProp => {
                            internalPropsByName.set(internalProp.name, internalProp);
                        });
                    }
                }
            });
            // Convert Chrome prop descriptors to DebugProtocol vars
            const variables = [];
            propsByName.forEach(propDesc => variables.push(this.propertyDescriptorToVariable(propDesc, objectId)));
            internalPropsByName.forEach(internalProp => variables.push(Promise.resolve(this.internalPropertyDescriptorToVariable(internalProp))));
            return Promise.all(variables);
        }).then(variables => {
            // Sort all variables properly
            return variables.sort((var1, var2) => ChromeUtils.compareVariableNames(var1.name, var2.name));
        });
    }
    internalPropertyDescriptorToVariable(propDesc) {
        return this.remoteObjectToVariable(propDesc.name, propDesc.value);
    }
    getFilteredVariablesForObject(objectId, filter, start, count) {
        // No ES6, in case we talk to an old runtime
        const getIndexedVariablesFn = `
            function getIndexedVariables(start, count) {
                var result = [];
                for (var i = start; i < (start + count); i++) result[i] = this[i];
                return result;
            }`;
        // TODO order??
        const getNamedVariablesFn = `
            function getNamedVariablesFn(start, count) {
                var result = [];
                var ownProps = Object.getOwnPropertyNames(this);
                for (var i = start; i < (start + count); i++) result[i] = ownProps[i];
                return result;
            }`;
        const getVarsFn = filter === 'indexed' ? getIndexedVariablesFn : getNamedVariablesFn;
        return this.getFilteredVariablesForObjectId(objectId, getVarsFn, filter, start, count);
    }
    getFilteredVariablesForObjectId(objectId, getVarsFn, filter, start, count) {
        return this._chromeConnection.runtime_callFunctionOn(objectId, getVarsFn, [{ value: start }, { value: count }], /*silent=*/ true).then(evalResponse => {
            if (evalResponse.error) {
                return Promise.reject(errors.errorFromEvaluate(evalResponse.error.message));
            }
            else if (evalResponse.result.exceptionDetails) {
                const errMsg = ChromeUtils.errorMessageFromExceptionDetails(evalResponse.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                // The eval was successful and returned a reference to the array object. Get the props, then filter
                // out everything except the index names.
                return this.getVariablesForObjectId(evalResponse.result.result.objectId, filter)
                    .then(variables => variables.filter(variable => variables_1.isIndexedPropName(variable.name)));
            }
        });
    }
    source(args) {
        const handle = this._sourceHandles.get(args.sourceReference);
        if (!handle) {
            return Promise.reject(errors.sourceRequestIllegalHandle());
        }
        // Have inlined content?
        if (handle.contents) {
            return Promise.resolve({
                content: handle.contents
            });
        }
        // If not, should have scriptId
        return this._chromeConnection.debugger_getScriptSource(handle.scriptId).then(chromeResponse => {
            return {
                content: chromeResponse.result.scriptSource,
                mimeType: 'text/javascript'
            };
        });
    }
    threads() {
        return {
            threads: [
                {
                    id: ChromeDebugAdapter.THREAD_ID,
                    name: 'Thread ' + ChromeDebugAdapter.THREAD_ID
                }
            ]
        };
    }
    evaluate(args) {
        let evalPromise;
        if (this.paused) {
            const callFrameId = this._currentStack[args.frameId].callFrameId;
            evalPromise = this._chromeConnection.debugger_evaluateOnCallFrame(callFrameId, args.expression, undefined, undefined, /*silent=*/ true);
        }
        else {
            evalPromise = this._chromeConnection.runtime_evaluate(args.expression, undefined, undefined, undefined, /*silent=*/ true);
        }
        return evalPromise.then(evalResponse => {
            if (evalResponse.result.wasThrown) {
                const evalResult = evalResponse.result;
                let errorMessage = 'Error';
                if (evalResult.exceptionDetails) {
                    errorMessage = evalResult.exceptionDetails.text;
                }
                else if (evalResult.result && evalResult.result.description) {
                    errorMessage = evalResult.result.description;
                }
                return utils.errP(errorMessage);
            }
            // Convert to a Variable object then just copy the relevant fields off
            return this.remoteObjectToVariable('', evalResponse.result.result);
        }).then(variable => {
            return {
                result: variable.value,
                variablesReference: variable.variablesReference,
                indexedVariables: variable.indexedVariables,
                namedVariables: variable.namedVariables
            };
        });
    }
    setVariable(args) {
        const handle = this._variableHandles.get(args.variablesReference);
        if (!handle) {
            return Promise.reject(errors.setValueNotSupported());
        }
        return handle.setValue(this, args.name, args.value)
            .then(value => ({ value }));
    }
    setVariableValue(frameId, scopeIndex, name, value) {
        let evalResultObject;
        return this._chromeConnection.debugger_evaluateOnCallFrame(frameId, value, undefined, undefined, /*silent=*/ true).then(evalResponse => {
            if (evalResponse.error) {
                return Promise.reject(errors.errorFromEvaluate(evalResponse.error.message));
            }
            else if (evalResponse.result.exceptionDetails) {
                const errMsg = ChromeUtils.errorMessageFromExceptionDetails(evalResponse.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                evalResultObject = evalResponse.result.result;
                const newVal = ChromeUtils.remoteObjectToCallArgument(evalResultObject);
                return this._chromeConnection.debugger_setVariableValue(frameId, scopeIndex, name, newVal);
            }
        })
            .then(setVarResponse => ChromeUtils.remoteObjectToValue(evalResultObject).value);
    }
    setPropertyValue(objectId, propName, value) {
        return this._chromeConnection.runtime_callFunctionOn(objectId, `function() { return this["${propName}"] = ${value} }`, undefined, /*silent=*/ true).then(response => {
            if (response.error) {
                return Promise.reject(errors.errorFromEvaluate(response.error.message));
            }
            else if (response.result.exceptionDetails) {
                const errMsg = ChromeUtils.errorMessageFromExceptionDetails(response.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                // Temporary, Microsoft/vscode#12019
                return ChromeUtils.remoteObjectToValue(response.result.result).value;
            }
        });
    }
    remoteObjectToVariable(name, object, stringify = true) {
        let value = '';
        if (object) {
            if (object.type === 'object') {
                if (object.subtype === 'internal#location') {
                    // Could format this nicely later, see #110
                    value = 'internal#location';
                }
                else if (object.subtype === 'null') {
                    value = 'null';
                }
                else {
                    return this.createObjectVariable(name, object);
                }
            }
            else if (object.type === 'undefined') {
                value = 'undefined';
            }
            else if (object.type === 'function') {
                return Promise.resolve(this.createFunctionVariable(name, object));
            }
            else {
                // The value is a primitive value, or something that has a description (not object, primitive, or undefined). And force to be string
                if (typeof object.value === 'undefined') {
                    value = object.description;
                }
                else if (object.type === 'number') {
                    // .value is truncated, so use .description, the full string representation
                    // Should be like '3' or 'Infinity'.
                    value = object.description;
                }
                else {
                    value = stringify ? JSON.stringify(object.value) : object.value;
                }
            }
        }
        return Promise.resolve({
            name,
            value,
            variablesReference: 0
        });
    }
    createFunctionVariable(name, object) {
        let value;
        const firstBraceIdx = object.description.indexOf('{');
        if (firstBraceIdx >= 0) {
            value = object.description.substring(0, firstBraceIdx) + '{ … }';
        }
        else {
            const firstArrowIdx = object.description.indexOf('=>');
            value = firstArrowIdx >= 0 ?
                object.description.substring(0, firstArrowIdx + 2) + ' …' :
                object.description;
        }
        return {
            name,
            value,
            variablesReference: this._variableHandles.create(new variables_1.PropertyContainer(object.objectId)),
            type: value
        };
    }
    createObjectVariable(name, object, stringify) {
        let value = object.description;
        let propCountP;
        if (object.subtype === 'array' || object.subtype === 'typedarray') {
            if (object.preview && !object.preview.overflow) {
                propCountP = Promise.resolve(this.getArrayNumPropsByPreview(object));
            }
            else {
                propCountP = this.getArrayNumPropsByEval(object.objectId);
            }
        }
        else if (object.subtype === 'set' || object.subtype === 'map') {
            if (object.preview && !object.preview.overflow) {
                propCountP = Promise.resolve(this.getCollectionNumPropsByPreview(object));
            }
            else {
                propCountP = this.getCollectionNumPropsByEval(object.objectId);
            }
        }
        else {
            if (object.subtype === 'error') {
                // The Error's description contains the whole stack which is not a nice description.
                // Up to the first newline is just the error name/message.
                const firstNewlineIdx = object.description.indexOf('\n');
                if (firstNewlineIdx >= 0)
                    value = object.description.substr(0, firstNewlineIdx);
            }
            else if (object.subtype === 'promise' && object.preview) {
                const promiseStatus = object.preview.properties.filter(prop => prop.name === '[[PromiseStatus]]')[0];
                if (promiseStatus)
                    value = object.description + ' { ' + promiseStatus.value + ' }';
            }
            else if (object.subtype === 'generator' && object.preview) {
                const generatorStatus = object.preview.properties.filter(prop => prop.name === '[[GeneratorStatus]]')[0];
                if (generatorStatus)
                    value = object.description + ' { ' + generatorStatus.value + ' }';
            }
            propCountP = Promise.resolve({});
        }
        const variablesReference = this._variableHandles.create(new variables_1.PropertyContainer(object.objectId));
        return propCountP.then(({ indexedVariables, namedVariables }) => ({
            name,
            value,
            type: value,
            variablesReference,
            indexedVariables,
            namedVariables
        }));
    }
    getArrayNumPropsByEval(objectId) {
        const getNumPropsFn = `function() { return [this.length, Object.keys(this).length - this.length]; }`;
        return this.getNumPropsByEval(objectId, getNumPropsFn);
    }
    getArrayNumPropsByPreview(object) {
        let indexedVariables = 0;
        let namedVariables = 0;
        object.preview.properties.forEach(prop => variables_1.isIndexedPropName(prop.name) ? indexedVariables++ : namedVariables++);
        return { indexedVariables, namedVariables };
    }
    getCollectionNumPropsByEval(objectId) {
        const getNumPropsFn = `function() { return [0, Object.keys(this).length + 1]; }`; // +1 for [[Entries]];
        return this.getNumPropsByEval(objectId, getNumPropsFn);
    }
    getCollectionNumPropsByPreview(object) {
        let indexedVariables = 0;
        let namedVariables = object.preview.properties.length + 1; // +1 for [[Entries]];
        return { indexedVariables, namedVariables };
    }
    getNumPropsByEval(objectId, getNumPropsFn) {
        return this._chromeConnection.runtime_callFunctionOn(objectId, getNumPropsFn, undefined, /*silent=*/ true, /*returnByValue=*/ true).then(response => {
            if (response.error) {
                return Promise.reject(errors.errorFromEvaluate(response.error.message));
            }
            else if (response.result.exceptionDetails) {
                const errMsg = ChromeUtils.errorMessageFromExceptionDetails(response.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                const resultProps = response.result.result.value;
                if (resultProps.length !== 2) {
                    return Promise.reject(errors.errorFromEvaluate("Did not get expected props, got " + JSON.stringify(resultProps)));
                }
                return { indexedVariables: resultProps[0], namedVariables: resultProps[1] };
            }
        });
    }
    shouldIgnoreScript(script) {
        return script.isContentScript || script.isInternalScript || script.url.startsWith('extensions::') || script.url.startsWith('chrome-extension://');
    }
}
ChromeDebugAdapter.THREAD_ID = 1;
ChromeDebugAdapter.PAGE_PAUSE_MESSAGE = 'Paused in Visual Studio Code';
ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL = 'debugadapter://';
ChromeDebugAdapter.SET_BREAKPOINTS_TIMEOUT = 3000;
exports.ChromeDebugAdapter = ChromeDebugAdapter;

//# sourceMappingURL=chromeDebugAdapter_BASE_12223.js.map
